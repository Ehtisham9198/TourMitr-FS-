// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __rest } from "tslib";
import { serializeChatRequestMessageUnion, serializeAzureChatExtensionConfigurationUnion, } from "../utils/serializeUtil.js";
import { isUnexpected, } from "../rest/index.js";
import { operationOptionsToRequestParameters, } from "@azure-rest/core-client";
import { getOaiSSEs } from "./oaiSse.js";
import { createFile } from "@azure/core-rest-pipeline";
import { snakeCaseKeys, camelCaseKeys } from "./util.js";
// implementation
export async function getAudioTranscription(context, deploymentName, fileContent, formatOrOptions, inputOptions) {
    const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : (typeof formatOrOptions === "string" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {});
    const response_format = typeof formatOrOptions === "string" ? formatOrOptions : undefined;
    const { abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = __rest(options, ["abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
    const { body, status } = await context
        .pathUnchecked("deployments/{deploymentName}/audio/transcriptions", deploymentName)
        .post(Object.assign(Object.assign({}, operationOptionsToRequestParameters({
        abortSignal,
        onResponse,
        tracingOptions,
        requestOptions,
    })), { contentType: "multipart/form-data", body: Object.assign(Object.assign(Object.assign({}, snakeCaseKeys(rest)), { file: createFile(fileContent, "placeholder.wav") }), (response_format ? { response_format } : {})) }));
    if (status !== "200") {
        throw body.error;
    }
    return response_format !== "verbose_json"
        ? body
        : camelCaseKeys(body);
}
// implementation
export async function getAudioTranslation(context, deploymentName, fileContent, formatOrOptions, inputOptions) {
    const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : (typeof formatOrOptions === "string" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {});
    const response_format = typeof formatOrOptions === "string" ? formatOrOptions : undefined;
    const { abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = __rest(options, ["abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
    const { body, status } = await context
        .pathUnchecked("deployments/{deploymentName}/audio/translations", deploymentName)
        .post(Object.assign(Object.assign({}, operationOptionsToRequestParameters({
        abortSignal,
        onResponse,
        tracingOptions,
        requestOptions,
    })), { contentType: "multipart/form-data", body: Object.assign(Object.assign(Object.assign({}, snakeCaseKeys(rest)), { file: createFile(fileContent, "placeholder.wav") }), (response_format ? { response_format } : {})) }));
    if (status !== "200") {
        throw body.error;
    }
    return response_format !== "verbose_json"
        ? body
        : camelCaseKeys(body);
}
export function _getCompletionsSend(context, deploymentId, body, options = { requestOptions: {} }) {
    return context.path("/deployments/{deploymentId}/completions", deploymentId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
            prompt: body["prompt"],
            max_tokens: body["maxTokens"],
            temperature: body["temperature"],
            top_p: body["topP"],
            logit_bias: body["logitBias"],
            user: body["user"],
            n: body["n"],
            logprobs: body["logprobs"],
            suffix: body["suffix"],
            echo: body["echo"],
            stop: body["stop"],
            presence_penalty: body["presencePenalty"],
            frequency_penalty: body["frequencyPenalty"],
            best_of: body["bestOf"],
            stream: body["stream"],
            model: body["model"],
        } }));
}
export async function _getCompletionsDeserialize(result) {
    if (isUnexpected(result)) {
        throw result.body.error;
    }
    return getCompletionsResult(result.body);
}
export function getCompletionsResult(body) {
    const { created, choices, prompt_filter_results, prompt_annotations } = body, rest = __rest(body, ["created", "choices", "prompt_filter_results", "prompt_annotations"]);
    return Object.assign(Object.assign(Object.assign(Object.assign({}, camelCaseKeys(rest)), { created: new Date(created) }), {
        promptFilterResults: getContentFilterResultsForPrompt({
            prompt_filter_results,
            prompt_annotations,
        }),
    }), { choices: choices.map((_a) => {
            var { content_filter_results } = _a, choice = __rest(_a, ["content_filter_results"]);
            return (Object.assign(Object.assign({}, camelCaseKeys(choice)), (!content_filter_results
                ? {}
                : {
                    contentFilterResults: parseContentFilterResultsForChoiceOutput(content_filter_results),
                })));
        }) });
}
/**
 * Gets completions for the provided input prompts.
 * Completions support a wide variety of tasks and generate text that continues from or "completes"
 * provided prompt data.
 */
export async function getCompletions(context, deploymentId, body, options = { requestOptions: {} }) {
    const result = await _getCompletionsSend(context, deploymentId, body, options);
    return _getCompletionsDeserialize(result);
}
export function streamCompletions(context, deploymentName, prompt, options = { requestOptions: {} }) {
    const { abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = __rest(options, ["abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
    const response = _getCompletionsSend(context, deploymentName, Object.assign(Object.assign({ prompt }, rest), { stream: true }), { abortSignal, onResponse, requestOptions, tracingOptions });
    return getOaiSSEs(response, getCompletionsResult);
}
export function _getChatCompletionsSend(context, deploymentId, body, options = { requestOptions: {} }) {
    var _a, _b, _c, _d, _e, _f, _g;
    return context.path("/deployments/{deploymentId}/chat/completions", deploymentId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
            model: body["model"],
            stream: body["stream"],
            max_tokens: body["maxTokens"],
            temperature: body["temperature"],
            top_p: body["topP"],
            logit_bias: body["logitBias"],
            user: body["user"],
            n: body["n"],
            stop: body["stop"],
            presence_penalty: body["presencePenalty"],
            frequency_penalty: body["frequencyPenalty"],
            data_sources: body["dataSources"] === undefined
                ? body["dataSources"]
                : body["dataSources"].map((p) => serializeAzureChatExtensionConfigurationUnion(p)),
            enhancements: !body.enhancements
                ? undefined
                : {
                    grounding: !((_a = body.enhancements) === null || _a === void 0 ? void 0 : _a.grounding)
                        ? undefined
                        : { enabled: (_c = (_b = body.enhancements) === null || _b === void 0 ? void 0 : _b.grounding) === null || _c === void 0 ? void 0 : _c["enabled"] },
                    ocr: !((_d = body.enhancements) === null || _d === void 0 ? void 0 : _d.ocr)
                        ? undefined
                        : { enabled: (_f = (_e = body.enhancements) === null || _e === void 0 ? void 0 : _e.ocr) === null || _f === void 0 ? void 0 : _f["enabled"] },
                },
            seed: body["seed"],
            logprobs: body["logprobs"],
            top_logprobs: body["topLogprobs"],
            response_format: !body.responseFormat ? undefined : { type: (_g = body.responseFormat) === null || _g === void 0 ? void 0 : _g["type"] },
            tool_choice: body["toolChoice"],
            tools: body["tools"],
            functions: body["functions"] === undefined
                ? body["functions"]
                : body["functions"].map((p) => ({
                    name: p["name"],
                    description: p["description"],
                    parameters: p["parameters"],
                })),
            function_call: body["functionCall"],
            messages: body["messages"].map((p) => serializeChatRequestMessageUnion(p)),
        } }));
}
export async function _getChatCompletionsDeserialize(result) {
    if (isUnexpected(result)) {
        throw result.body.error;
    }
    return getChatCompletionsResult(result.body);
}
export function getChatCompletionsResult(body) {
    const { created, choices, prompt_filter_results, prompt_annotations, usage } = body, rest = __rest(body, ["created", "choices", "prompt_filter_results", "prompt_annotations", "usage"]);
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, camelCaseKeys(rest)), { created: new Date(created) }), {
        promptFilterResults: getContentFilterResultsForPrompt({
            prompt_filter_results,
            prompt_annotations,
        }),
    }), (!usage
        ? {}
        : {
            usage: {
                completionTokens: usage["completion_tokens"],
                promptTokens: usage["prompt_tokens"],
                totalTokens: usage["total_tokens"],
            },
        })), { choices: !choices
            ? []
            : choices.map((_a) => {
                var { content_filter_results } = _a, choice = __rest(_a, ["content_filter_results"]);
                return (Object.assign(Object.assign({}, camelCaseKeys(choice)), (!content_filter_results
                    ? {}
                    : {
                        contentFilterResults: parseContentFilterResultsForChoiceOutput(content_filter_results),
                    })));
            }) });
}
/**
 * Gets chat completions for the provided chat messages.
 * Completions support a wide variety of tasks and generate text that continues from or "completes"
 * provided prompt data.
 */
export async function getChatCompletions(context, deploymentName, messages, options = { requestOptions: {} }) {
    const result = await _getChatCompletionsSendX(context, deploymentName, messages, options);
    return _getChatCompletionsDeserialize(result);
}
function _getChatCompletionsSendX(context, deploymentName, messages, options = { requestOptions: {} }) {
    const { azureExtensionOptions, abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = __rest(options, ["azureExtensionOptions", "abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
    const coreOptions = {
        abortSignal,
        onResponse,
        requestOptions,
        tracingOptions,
    };
    const azure = Object.assign(Object.assign({}, (!(azureExtensionOptions === null || azureExtensionOptions === void 0 ? void 0 : azureExtensionOptions.extensions)
        ? {}
        : { dataSources: azureExtensionOptions.extensions })), (!(azureExtensionOptions === null || azureExtensionOptions === void 0 ? void 0 : azureExtensionOptions.enhancements)
        ? {}
        : { enhancements: azureExtensionOptions.enhancements }));
    return _getChatCompletionsSend(context, deploymentName, Object.assign(Object.assign({ messages }, rest), azure), coreOptions);
}
export function streamChatCompletions(context, deploymentName, messages, options = { requestOptions: {} }) {
    const response = _getChatCompletionsSendX(context, deploymentName, messages, Object.assign(Object.assign({}, options), { stream: true }));
    return getOaiSSEs(response, getChatCompletionsResult);
}
export function _getImageGenerationsSend(context, deploymentId, body, options = { requestOptions: {} }) {
    return context.path("/deployments/{deploymentId}/images/generations", deploymentId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
            model: body["model"],
            prompt: body["prompt"],
            n: body["n"],
            size: body["size"],
            response_format: body["responseFormat"],
            quality: body["quality"],
            style: body["style"],
            user: body["user"],
        } }));
}
export async function _getImageGenerationsDeserialize(result) {
    if (isUnexpected(result)) {
        throw result.body.error;
    }
    return {
        created: new Date(result.body["created"]),
        data: result.body["data"].map((p) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25;
            return ({
                url: p["url"],
                base64Data: p["b64_json"],
                contentFilterResults: !p.content_filter_results
                    ? undefined
                    : {
                        sexual: !((_a = p.content_filter_results) === null || _a === void 0 ? void 0 : _a.sexual)
                            ? undefined
                            : {
                                severity: (_c = (_b = p.content_filter_results) === null || _b === void 0 ? void 0 : _b.sexual) === null || _c === void 0 ? void 0 : _c["severity"],
                                filtered: (_e = (_d = p.content_filter_results) === null || _d === void 0 ? void 0 : _d.sexual) === null || _e === void 0 ? void 0 : _e["filtered"],
                            },
                        violence: !((_f = p.content_filter_results) === null || _f === void 0 ? void 0 : _f.violence)
                            ? undefined
                            : {
                                severity: (_h = (_g = p.content_filter_results) === null || _g === void 0 ? void 0 : _g.violence) === null || _h === void 0 ? void 0 : _h["severity"],
                                filtered: (_k = (_j = p.content_filter_results) === null || _j === void 0 ? void 0 : _j.violence) === null || _k === void 0 ? void 0 : _k["filtered"],
                            },
                        hate: !((_l = p.content_filter_results) === null || _l === void 0 ? void 0 : _l.hate)
                            ? undefined
                            : {
                                severity: (_o = (_m = p.content_filter_results) === null || _m === void 0 ? void 0 : _m.hate) === null || _o === void 0 ? void 0 : _o["severity"],
                                filtered: (_q = (_p = p.content_filter_results) === null || _p === void 0 ? void 0 : _p.hate) === null || _q === void 0 ? void 0 : _q["filtered"],
                            },
                        selfHarm: !((_r = p.content_filter_results) === null || _r === void 0 ? void 0 : _r.self_harm)
                            ? undefined
                            : {
                                severity: (_t = (_s = p.content_filter_results) === null || _s === void 0 ? void 0 : _s.self_harm) === null || _t === void 0 ? void 0 : _t["severity"],
                                filtered: (_v = (_u = p.content_filter_results) === null || _u === void 0 ? void 0 : _u.self_harm) === null || _v === void 0 ? void 0 : _v["filtered"],
                            },
                    },
                revisedPrompt: p["revised_prompt"],
                promptFilterResults: !p.prompt_filter_results
                    ? undefined
                    : {
                        sexual: !((_w = p.prompt_filter_results) === null || _w === void 0 ? void 0 : _w.sexual)
                            ? undefined
                            : {
                                severity: (_y = (_x = p.prompt_filter_results) === null || _x === void 0 ? void 0 : _x.sexual) === null || _y === void 0 ? void 0 : _y["severity"],
                                filtered: (_0 = (_z = p.prompt_filter_results) === null || _z === void 0 ? void 0 : _z.sexual) === null || _0 === void 0 ? void 0 : _0["filtered"],
                            },
                        violence: !((_1 = p.prompt_filter_results) === null || _1 === void 0 ? void 0 : _1.violence)
                            ? undefined
                            : {
                                severity: (_3 = (_2 = p.prompt_filter_results) === null || _2 === void 0 ? void 0 : _2.violence) === null || _3 === void 0 ? void 0 : _3["severity"],
                                filtered: (_5 = (_4 = p.prompt_filter_results) === null || _4 === void 0 ? void 0 : _4.violence) === null || _5 === void 0 ? void 0 : _5["filtered"],
                            },
                        hate: !((_6 = p.prompt_filter_results) === null || _6 === void 0 ? void 0 : _6.hate)
                            ? undefined
                            : {
                                severity: (_8 = (_7 = p.prompt_filter_results) === null || _7 === void 0 ? void 0 : _7.hate) === null || _8 === void 0 ? void 0 : _8["severity"],
                                filtered: (_10 = (_9 = p.prompt_filter_results) === null || _9 === void 0 ? void 0 : _9.hate) === null || _10 === void 0 ? void 0 : _10["filtered"],
                            },
                        selfHarm: !((_11 = p.prompt_filter_results) === null || _11 === void 0 ? void 0 : _11.self_harm)
                            ? undefined
                            : {
                                severity: (_13 = (_12 = p.prompt_filter_results) === null || _12 === void 0 ? void 0 : _12.self_harm) === null || _13 === void 0 ? void 0 : _13["severity"],
                                filtered: (_15 = (_14 = p.prompt_filter_results) === null || _14 === void 0 ? void 0 : _14.self_harm) === null || _15 === void 0 ? void 0 : _15["filtered"],
                            },
                        profanity: !((_16 = p.prompt_filter_results) === null || _16 === void 0 ? void 0 : _16.profanity)
                            ? undefined
                            : {
                                filtered: (_18 = (_17 = p.prompt_filter_results) === null || _17 === void 0 ? void 0 : _17.profanity) === null || _18 === void 0 ? void 0 : _18["filtered"],
                                detected: (_20 = (_19 = p.prompt_filter_results) === null || _19 === void 0 ? void 0 : _19.profanity) === null || _20 === void 0 ? void 0 : _20["detected"],
                            },
                        jailbreak: !((_21 = p.prompt_filter_results) === null || _21 === void 0 ? void 0 : _21.jailbreak)
                            ? undefined
                            : {
                                filtered: (_23 = (_22 = p.prompt_filter_results) === null || _22 === void 0 ? void 0 : _22.jailbreak) === null || _23 === void 0 ? void 0 : _23["filtered"],
                                detected: (_25 = (_24 = p.prompt_filter_results) === null || _24 === void 0 ? void 0 : _24.jailbreak) === null || _25 === void 0 ? void 0 : _25["detected"],
                            },
                    },
            });
        }),
    };
}
/** Creates an image given a prompt. */
export async function getImageGenerations(context, deploymentId, body, options = { requestOptions: {} }) {
    const result = await _getImageGenerationsSend(context, deploymentId, body, options);
    return _getImageGenerationsDeserialize(result);
}
export function _getEmbeddingsSend(context, deploymentId, body, options = { requestOptions: {} }) {
    return context.path("/deployments/{deploymentId}/embeddings", deploymentId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
            user: body["user"],
            model: body["model"],
            input: body["input"],
            dimensions: body["dimensions"],
        } }));
}
export async function _getEmbeddingsDeserialize(result) {
    if (isUnexpected(result)) {
        throw result.body.error;
    }
    return {
        data: result.body["data"].map((p) => ({
            embedding: p["embedding"],
            index: p["index"],
        })),
        usage: {
            promptTokens: result.body.usage["prompt_tokens"],
            totalTokens: result.body.usage["total_tokens"],
        },
    };
}
/** Return the embeddings for a given prompt. */
export async function getEmbeddings(context, deploymentId, body, options = { requestOptions: {} }) {
    const result = await _getEmbeddingsSend(context, deploymentId, body, options);
    return _getEmbeddingsDeserialize(result);
}
function getContentFilterResultsForPrompt({ prompt_annotations, prompt_filter_results, }) {
    const res = prompt_filter_results !== null && prompt_filter_results !== void 0 ? prompt_filter_results : prompt_annotations;
    return res === null || res === void 0 ? void 0 : res.map((_a) => {
        var { content_filter_results } = _a, rest = __rest(_a, ["content_filter_results"]);
        return (Object.assign(Object.assign({}, camelCaseKeys(rest)), { contentFilterResults: parseContentFilterResultDetailsForPromptOutput(content_filter_results) }));
    });
}
function parseContentFilterResultDetailsForPromptOutput(_a = {}) {
    var { error } = _a, rest = __rest(_a, ["error"]);
    return error ? parseError(error) : camelCaseKeys(rest);
}
function parseError(error) {
    var _a;
    return {
        error: Object.assign(Object.assign({}, error), { details: (_a = error["details"]) !== null && _a !== void 0 ? _a : [] }),
    };
}
function parseContentFilterResultsForChoiceOutput(_a = {}) {
    var _b;
    var { error } = _a, successResult = __rest(_a, ["error"]);
    return error
        ? {
            error: Object.assign(Object.assign({}, error), { details: (_b = error["details"]) !== null && _b !== void 0 ? _b : [] }),
        }
        : camelCaseKeys(successResult);
}
//# sourceMappingURL=operations.js.map