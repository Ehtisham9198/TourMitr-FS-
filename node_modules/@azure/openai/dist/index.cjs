'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreAuth = require('@azure/core-auth');
var tslib = require('tslib');
var coreClient = require('@azure-rest/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreSse = require('@azure/core-sse');
var logger$1 = require('@azure/logger');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const logger = logger$1.createClientLogger("openai");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Initialize a new instance of `OpenAIContext`
 * @param endpoint - Supported Cognitive Services endpoints (protocol and hostname, for example:
 * https://westus.api.cognitive.microsoft.com).
 * @param credentials - uniquely identify client credential
 * @param options - the parameter for all optional parameters
 */
function createClient(endpoint, credentials, options = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const baseUrl = (_a = options.baseUrl) !== null && _a !== void 0 ? _a : `${endpoint}/openai`;
    options.apiVersion = (_b = options.apiVersion) !== null && _b !== void 0 ? _b : "2024-03-01-preview";
    const userAgentInfo = `azsdk-js-openai-rest/1.0.0-beta.12`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
        ? `${options.userAgentOptions.userAgentPrefix} ${userAgentInfo}`
        : `${userAgentInfo}`;
    options = Object.assign(Object.assign({}, options), { userAgentOptions: {
            userAgentPrefix,
        }, loggingOptions: {
            logger: (_d = (_c = options.loggingOptions) === null || _c === void 0 ? void 0 : _c.logger) !== null && _d !== void 0 ? _d : logger.info,
        }, credentials: {
            scopes: (_f = (_e = options.credentials) === null || _e === void 0 ? void 0 : _e.scopes) !== null && _f !== void 0 ? _f : ["https://cognitiveservices.azure.com/.default"],
            apiKeyHeaderName: (_h = (_g = options.credentials) === null || _g === void 0 ? void 0 : _g.apiKeyHeaderName) !== null && _h !== void 0 ? _h : "api-key",
        } });
    const client = coreClient.getClient(baseUrl, credentials, options);
    return client;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const responseMap = {
    "POST /deployments/{deploymentId}/audio/transcriptions": ["200"],
    "POST /deployments/{deploymentId}/audio/translations": ["200"],
    "POST /deployments/{deploymentId}/completions": ["200"],
    "POST /deployments/{deploymentId}/chat/completions": ["200"],
    "POST /deployments/{deploymentId}/images/generations": ["200"],
    "POST /deployments/{deploymentId}/embeddings": ["200"],
    "GET /operations/images/{operationId}": ["200"],
    "POST /images/generations:submit": ["202"],
    "GET /images/generations:submit": ["200", "202"],
};
function isUnexpected(response) {
    const lroOriginal = response.headers["x-ms-original-url"];
    const url = new URL(lroOriginal !== null && lroOriginal !== void 0 ? lroOriginal : response.request.url);
    const method = response.request.method;
    let pathDetails = responseMap[`${method} ${url.pathname}`];
    if (!pathDetails) {
        pathDetails = getParametrizedPathSuccess(method, url.pathname);
    }
    return !pathDetails.includes(response.status);
}
function getParametrizedPathSuccess(method, path) {
    var _a, _b, _c, _d;
    const pathParts = path.split("/");
    // Traverse list to match the longest candidate
    // matchedLen: the length of candidate path
    // matchedValue: the matched status code array
    let matchedLen = -1, matchedValue = [];
    // Iterate the responseMap to find a match
    for (const [key, value] of Object.entries(responseMap)) {
        // Extracting the path from the map key which is in format
        // GET /path/foo
        if (!key.startsWith(method)) {
            continue;
        }
        const candidatePath = getPathFromMapKey(key);
        // Get each part of the url path
        const candidateParts = candidatePath.split("/");
        // track if we have found a match to return the values found.
        let found = true;
        for (let i = candidateParts.length - 1, j = pathParts.length - 1; i >= 1 && j >= 1; i--, j--) {
            if (((_a = candidateParts[i]) === null || _a === void 0 ? void 0 : _a.startsWith("{")) && ((_b = candidateParts[i]) === null || _b === void 0 ? void 0 : _b.indexOf("}")) !== -1) {
                const start = candidateParts[i].indexOf("}") + 1, end = (_c = candidateParts[i]) === null || _c === void 0 ? void 0 : _c.length;
                // If the current part of the candidate is a "template" part
                // Try to use the suffix of pattern to match the path
                // {guid} ==> $
                // {guid}:export ==> :export$
                const isMatched = new RegExp(`${(_d = candidateParts[i]) === null || _d === void 0 ? void 0 : _d.slice(start, end)}`).test(pathParts[j] || "");
                if (!isMatched) {
                    found = false;
                    break;
                }
                continue;
            }
            // If the candidate part is not a template and
            // the parts don't match mark the candidate as not found
            // to move on with the next candidate path.
            if (candidateParts[i] !== pathParts[j]) {
                found = false;
                break;
            }
        }
        // We finished evaluating the current candidate parts
        // Update the matched value if and only if we found the longer pattern
        if (found && candidatePath.length > matchedLen) {
            matchedLen = candidatePath.length;
            matchedValue = value;
        }
    }
    return matchedValue;
}
function getPathFromMapKey(mapKey) {
    const pathStart = mapKey.indexOf("/");
    return mapKey.slice(pathStart);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function createOpenAI(endpoint, credential, options = {}) {
    const clientContext = createClient(endpoint, credential, options);
    return clientContext;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function wrapError(f, message) {
    try {
        const result = f();
        return result;
    }
    catch (cause) {
        throw new Error(`${message}: ${cause}`, { cause });
    }
}
function camelCaseKeys(obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    if (Array.isArray(obj)) {
        return obj.map((v) => camelCaseKeys(v));
    }
    else {
        for (const key of Object.keys(obj)) {
            const value = obj[key];
            const newKey = tocamelCase(key);
            if (newKey !== key) {
                delete obj[key];
            }
            obj[newKey] =
                typeof obj[newKey] === "object" ? camelCaseKeys(value) : value;
        }
        return obj;
    }
}
function snakeCaseKeys(obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    if (Array.isArray(obj)) {
        return obj.map((v) => snakeCaseKeys(v));
    }
    else {
        for (const key of Object.keys(obj)) {
            const value = obj[key];
            const newKey = toSnakeCase(key);
            if (newKey !== key) {
                delete obj[key];
            }
            obj[newKey] =
                typeof obj[newKey] === "object" ? snakeCaseKeys(value) : value;
        }
        return obj;
    }
}
function tocamelCase(str) {
    return str
        .toLowerCase()
        .replace(/([_][a-z])/g, (group) => group.toUpperCase().replace("_", ""));
}
function toSnakeCase(str) {
    return str
        .replace(/([A-Z])/g, (group) => `_${group.toLowerCase()}`)
        .replace(/^_/, "");
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/** serialize function for ChatRequestUserMessage */
function serializeChatRequestUserMessage(obj) {
    return {
        role: obj["role"],
        content: typeof obj["content"] === "string"
            ? obj["content"]
            : obj["content"].map(serializeChatRequestContentItemUnion),
        name: obj["name"],
    };
}
/** serialize function for ChatMessageImageContentItem */
function serializeChatRequestContentItemUnion(obj) {
    switch (obj.type) {
        case "image_url":
            return serializeChatMessageImageContentItem(obj);
        default:
            return obj;
    }
}
/** serialize function for ChatRequestAssistantMessage */
function serializeChatRequestAssistantMessage(obj) {
    if (obj.content === undefined) {
        obj.content = null;
    }
    const { functionCall, toolCalls } = obj, rest = tslib.__rest(obj, ["functionCall", "toolCalls"]);
    return Object.assign(Object.assign(Object.assign({}, snakeCaseKeys(rest)), (!toolCalls || toolCalls.length === 0 ? {} : { tool_calls: toolCalls })), (functionCall ? { function_call: functionCall } : {}));
}
/** serialize function for ChatRequestToolMessage */
function serializeChatRequestToolMessage(obj) {
    return {
        role: obj["role"],
        content: obj["content"],
        tool_call_id: obj["toolCallId"],
    };
}
/** serialize function for ChatRequestMessageUnion */
function serializeChatRequestMessageUnion(obj) {
    switch (obj.role) {
        case "user":
            return serializeChatRequestUserMessage(obj);
        case "assistant":
            return serializeChatRequestAssistantMessage(obj);
        case "tool":
            return serializeChatRequestToolMessage(obj);
        default:
            return obj;
    }
}
/** serialize function for ChatMessageImageContentItem */
function serializeChatMessageImageContentItem(obj) {
    return {
        type: obj["type"],
        image_url: { url: obj.imageUrl["url"], detail: obj.imageUrl["detail"] },
    };
}
/** serialize function for AzureSearchChatExtensionConfiguration */
function serializeAzureSearchChatExtensionConfiguration(obj) {
    var _a, _b, _c, _d, _e, _f, _g;
    return {
        type: obj["type"],
        parameters: {
            authentication: !obj.authentication
                ? obj.authentication
                : serializeOnYourDataAuthenticationOptionsUnion(obj.authentication),
            top_n_documents: obj["topNDocuments"],
            in_scope: obj["inScope"],
            strictness: obj["strictness"],
            role_information: obj["roleInformation"],
            endpoint: obj["endpoint"],
            index_name: obj["indexName"],
            fields_mapping: !obj.fieldsMapping
                ? undefined
                : {
                    title_field: (_a = obj.fieldsMapping) === null || _a === void 0 ? void 0 : _a["titleField"],
                    url_field: (_b = obj.fieldsMapping) === null || _b === void 0 ? void 0 : _b["urlField"],
                    filepath_field: (_c = obj.fieldsMapping) === null || _c === void 0 ? void 0 : _c["filepathField"],
                    content_fields: (_d = obj.fieldsMapping) === null || _d === void 0 ? void 0 : _d["contentFields"],
                    content_fields_separator: (_e = obj.fieldsMapping) === null || _e === void 0 ? void 0 : _e["contentFieldsSeparator"],
                    vector_fields: (_f = obj.fieldsMapping) === null || _f === void 0 ? void 0 : _f["vectorFields"],
                    image_vector_fields: (_g = obj.fieldsMapping) === null || _g === void 0 ? void 0 : _g["imageVectorFields"],
                },
            query_type: obj["queryType"],
            semantic_configuration: obj["semanticConfiguration"],
            filter: obj["filter"],
            embedding_dependency: !obj.embeddingDependency
                ? obj.embeddingDependency
                : serializeOnYourDataVectorizationSourceUnion(obj.embeddingDependency),
        },
    };
}
/** serialize function for AzureMachineLearningIndexChatExtensionConfiguration */
function serializeAzureMachineLearningIndexChatExtensionConfiguration(obj) {
    return {
        type: obj["type"],
        parameters: {
            authentication: !obj.authentication
                ? obj.authentication
                : serializeOnYourDataAuthenticationOptionsUnion(obj.authentication),
            top_n_documents: obj["topNDocuments"],
            in_scope: obj["inScope"],
            strictness: obj["strictness"],
            role_information: obj["roleInformation"],
            project_resource_id: obj["projectResourceId"],
            name: obj["name"],
            version: obj["version"],
            filter: obj["filter"],
        },
    };
}
/** serialize function for AzureCosmosDBChatExtensionConfiguration */
function serializeAzureCosmosDBChatExtensionConfiguration(obj) {
    return {
        type: obj["type"],
        parameters: {
            authentication: !obj.authentication
                ? obj.authentication
                : serializeOnYourDataAuthenticationOptionsUnion(obj.authentication),
            top_n_documents: obj["topNDocuments"],
            in_scope: obj["inScope"],
            strictness: obj["strictness"],
            role_information: obj["roleInformation"],
            database_name: obj["databaseName"],
            container_name: obj["containerName"],
            index_name: obj["indexName"],
            fields_mapping: {
                title_field: obj.fieldsMapping["titleField"],
                url_field: obj.fieldsMapping["urlField"],
                filepath_field: obj.fieldsMapping["filepathField"],
                content_fields: obj.fieldsMapping["contentFields"],
                content_fields_separator: obj.fieldsMapping["contentFieldsSeparator"],
                vector_fields: obj.fieldsMapping["vectorFields"],
            },
            embedding_dependency: serializeOnYourDataVectorizationSourceUnion(obj.embeddingDependency),
        },
    };
}
/** serialize function for ElasticsearchChatExtensionConfiguration */
function serializeElasticsearchChatExtensionConfiguration(obj) {
    var _a, _b, _c, _d, _e, _f;
    return {
        type: obj["type"],
        parameters: {
            authentication: !obj.authentication
                ? obj.authentication
                : serializeOnYourDataAuthenticationOptionsUnion(obj.authentication),
            top_n_documents: obj["topNDocuments"],
            in_scope: obj["inScope"],
            strictness: obj["strictness"],
            role_information: obj["roleInformation"],
            endpoint: obj["endpoint"],
            index_name: obj["indexName"],
            fields_mapping: !obj.fieldsMapping
                ? undefined
                : {
                    title_field: (_a = obj.fieldsMapping) === null || _a === void 0 ? void 0 : _a["titleField"],
                    url_field: (_b = obj.fieldsMapping) === null || _b === void 0 ? void 0 : _b["urlField"],
                    filepath_field: (_c = obj.fieldsMapping) === null || _c === void 0 ? void 0 : _c["filepathField"],
                    content_fields: (_d = obj.fieldsMapping) === null || _d === void 0 ? void 0 : _d["contentFields"],
                    content_fields_separator: (_e = obj.fieldsMapping) === null || _e === void 0 ? void 0 : _e["contentFieldsSeparator"],
                    vector_fields: (_f = obj.fieldsMapping) === null || _f === void 0 ? void 0 : _f["vectorFields"],
                },
            query_type: obj["queryType"],
            embedding_dependency: !obj.embeddingDependency
                ? obj.embeddingDependency
                : serializeOnYourDataVectorizationSourceUnion(obj.embeddingDependency),
        },
    };
}
/** serialize function for PineconeChatExtensionConfiguration */
function serializePineconeChatExtensionConfiguration(obj) {
    return {
        type: obj["type"],
        parameters: {
            authentication: !obj.authentication
                ? obj.authentication
                : serializeOnYourDataAuthenticationOptionsUnion(obj.authentication),
            top_n_documents: obj["topNDocuments"],
            in_scope: obj["inScope"],
            strictness: obj["strictness"],
            role_information: obj["roleInformation"],
            environment: obj["environment"],
            index_name: obj["indexName"],
            fields_mapping: {
                title_field: obj.fieldsMapping["titleField"],
                url_field: obj.fieldsMapping["urlField"],
                filepath_field: obj.fieldsMapping["filepathField"],
                content_fields: obj.fieldsMapping["contentFields"],
                content_fields_separator: obj.fieldsMapping["contentFieldsSeparator"],
            },
            embedding_dependency: serializeOnYourDataVectorizationSourceUnion(obj.embeddingDependency),
        },
    };
}
/** serialize function for AzureChatExtensionConfigurationUnion */
function serializeAzureChatExtensionConfigurationUnion(obj) {
    switch (obj.type) {
        case "azure_search":
            return serializeAzureSearchChatExtensionConfiguration(obj);
        case "azure_ml_index":
            return serializeAzureMachineLearningIndexChatExtensionConfiguration(obj);
        case "azure_cosmos_db":
            return serializeAzureCosmosDBChatExtensionConfiguration(obj);
        case "elasticsearch":
            return serializeElasticsearchChatExtensionConfiguration(obj);
        case "pinecone":
            return serializePineconeChatExtensionConfiguration(obj);
        default:
            return obj;
    }
}
/** serialize function for OnYourDataConnectionStringAuthenticationOptions */
function serializeOnYourDataConnectionStringAuthenticationOptions(obj) {
    return { type: obj["type"], connection_string: obj["connectionString"] };
}
/** serialize function for OnYourDataKeyAndKeyIdAuthenticationOptions */
function serializeOnYourDataKeyAndKeyIdAuthenticationOptions(obj) {
    return { type: obj["type"], key: obj["key"], key_id: obj["keyId"] };
}
/** serialize function for OnYourDataEncodedApiKeyAuthenticationOptions */
function serializeOnYourDataEncodedApiKeyAuthenticationOptions(obj) {
    return { type: obj["type"], encoded_api_key: obj["encodedApiKey"] };
}
/** serialize function for OnYourDataAccessTokenAuthenticationOptions */
function serializeOnYourDataAccessTokenAuthenticationOptions(obj) {
    return { type: obj["type"], access_token: obj["accessToken"] };
}
/** serialize function for OnYourDataUserAssignedManagedIdentityAuthenticationOptions */
function serializeOnYourDataUserAssignedManagedIdentityAuthenticationOptions(obj) {
    return {
        type: obj["type"],
        managed_identity_resource_id: obj["managedIdentityResourceId"],
    };
}
/** serialize function for OnYourDataAuthenticationOptionsUnion */
function serializeOnYourDataAuthenticationOptionsUnion(obj) {
    switch (obj.type) {
        case "connection_string":
            return serializeOnYourDataConnectionStringAuthenticationOptions(obj);
        case "key_and_key_id":
            return serializeOnYourDataKeyAndKeyIdAuthenticationOptions(obj);
        case "encoded_api_key":
            return serializeOnYourDataEncodedApiKeyAuthenticationOptions(obj);
        case "access_token":
            return serializeOnYourDataAccessTokenAuthenticationOptions(obj);
        case "user_assigned_managed_identity":
            return serializeOnYourDataUserAssignedManagedIdentityAuthenticationOptions(obj);
        default:
            return obj;
    }
}
/** serialize function for OnYourDataEndpointVectorizationSource */
function serializeOnYourDataEndpointVectorizationSource(obj) {
    return {
        type: obj["type"],
        endpoint: obj["endpoint"],
        authentication: serializeOnYourDataAuthenticationOptionsUnion(obj.authentication),
    };
}
/** serialize function for OnYourDataDeploymentNameVectorizationSource */
function serializeOnYourDataDeploymentNameVectorizationSource(obj) {
    return { type: obj["type"], deployment_name: obj["deploymentName"] };
}
/** serialize function for OnYourDataModelIdVectorizationSource */
function serializeOnYourDataModelIdVectorizationSource(obj) {
    return { type: obj["type"], model_id: obj["modelId"] };
}
/** serialize function for OnYourDataVectorizationSourceUnion */
function serializeOnYourDataVectorizationSourceUnion(obj) {
    switch (obj.type) {
        case "endpoint":
            return serializeOnYourDataEndpointVectorizationSource(obj);
        case "deployment_name":
            return serializeOnYourDataDeploymentNameVectorizationSource(obj);
        case "model_id":
            return serializeOnYourDataModelIdVectorizationSource(obj);
        default:
            return obj;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
async function getStream(response) {
    const { body, status } = await response.asNodeStream();
    if (status !== "200" && body !== undefined) {
        const text = await streamToText(body);
        throw wrapError(() => JSON.parse(text).error, "Error parsing response body");
    }
    if (!body)
        throw new Error("No stream found in response. Did you enable the stream option?");
    return body;
}
function streamToText(stream) {
    return new Promise((resolve, reject) => {
        const buffer = [];
        stream.on("data", (chunk) => {
            if (Buffer.isBuffer(chunk)) {
                buffer.push(chunk);
            }
            else {
                buffer.push(Buffer.from(chunk));
            }
        });
        stream.on("end", () => {
            resolve(Buffer.concat(buffer).toString("utf8"));
        });
        stream.on("error", (e) => {
            if (e && (e === null || e === void 0 ? void 0 : e.name) === "AbortError") {
                reject(e);
            }
            else {
                reject(new coreRestPipeline.RestError(`Error reading response as text: ${e.message}`, {
                    code: coreRestPipeline.RestError.PARSE_ERROR,
                }));
            }
        });
    });
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function polyfillStream(stream) {
    makeAsyncIterable(stream);
    return stream;
}
function makeAsyncIterable(webStream) {
    if (!webStream[Symbol.asyncIterator]) {
        webStream[Symbol.asyncIterator] = () => toAsyncIterable(webStream);
    }
    if (!webStream.values) {
        webStream.values = () => toAsyncIterable(webStream);
    }
}
function toAsyncIterable(stream) {
    return tslib.__asyncGenerator(this, arguments, function* toAsyncIterable_1() {
        const reader = stream.getReader();
        try {
            while (true) {
                const { value, done } = yield tslib.__await(reader.read());
                if (done) {
                    return yield tslib.__await(void 0);
                }
                yield yield tslib.__await(value);
            }
        }
        finally {
            const cancelPromise = reader.cancel();
            reader.releaseLock();
            yield tslib.__await(cancelPromise);
        }
    });
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
async function getOaiSSEs(response, toEvent) {
    const stringStream = await getStream(response);
    const eventStream = coreSse.createSseStream(stringStream);
    const jsonParser = new TransformStream({
        transform: async (chunk, controller) => {
            if (chunk.data === "[DONE]") {
                return;
            }
            controller.enqueue(toEvent(wrapError(() => JSON.parse(chunk.data), "Error parsing an event. See 'cause' for more details")));
        },
    });
    /** TODO: remove these polyfills once all supported runtimes support them */
    return polyfillStream(eventStream.pipeThrough(jsonParser));
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// implementation
async function getAudioTranscription(context, deploymentName, fileContent, formatOrOptions, inputOptions) {
    const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : (typeof formatOrOptions === "string" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {});
    const response_format = typeof formatOrOptions === "string" ? formatOrOptions : undefined;
    const { abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = tslib.__rest(options, ["abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
    const { body, status } = await context
        .pathUnchecked("deployments/{deploymentName}/audio/transcriptions", deploymentName)
        .post(Object.assign(Object.assign({}, coreClient.operationOptionsToRequestParameters({
        abortSignal,
        onResponse,
        tracingOptions,
        requestOptions,
    })), { contentType: "multipart/form-data", body: Object.assign(Object.assign(Object.assign({}, snakeCaseKeys(rest)), { file: coreRestPipeline.createFile(fileContent, "placeholder.wav") }), (response_format ? { response_format } : {})) }));
    if (status !== "200") {
        throw body.error;
    }
    return response_format !== "verbose_json"
        ? body
        : camelCaseKeys(body);
}
// implementation
async function getAudioTranslation(context, deploymentName, fileContent, formatOrOptions, inputOptions) {
    const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : (typeof formatOrOptions === "string" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {});
    const response_format = typeof formatOrOptions === "string" ? formatOrOptions : undefined;
    const { abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = tslib.__rest(options, ["abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
    const { body, status } = await context
        .pathUnchecked("deployments/{deploymentName}/audio/translations", deploymentName)
        .post(Object.assign(Object.assign({}, coreClient.operationOptionsToRequestParameters({
        abortSignal,
        onResponse,
        tracingOptions,
        requestOptions,
    })), { contentType: "multipart/form-data", body: Object.assign(Object.assign(Object.assign({}, snakeCaseKeys(rest)), { file: coreRestPipeline.createFile(fileContent, "placeholder.wav") }), (response_format ? { response_format } : {})) }));
    if (status !== "200") {
        throw body.error;
    }
    return response_format !== "verbose_json"
        ? body
        : camelCaseKeys(body);
}
function _getCompletionsSend(context, deploymentId, body, options = { requestOptions: {} }) {
    return context.path("/deployments/{deploymentId}/completions", deploymentId).post(Object.assign(Object.assign({}, coreClient.operationOptionsToRequestParameters(options)), { body: {
            prompt: body["prompt"],
            max_tokens: body["maxTokens"],
            temperature: body["temperature"],
            top_p: body["topP"],
            logit_bias: body["logitBias"],
            user: body["user"],
            n: body["n"],
            logprobs: body["logprobs"],
            suffix: body["suffix"],
            echo: body["echo"],
            stop: body["stop"],
            presence_penalty: body["presencePenalty"],
            frequency_penalty: body["frequencyPenalty"],
            best_of: body["bestOf"],
            stream: body["stream"],
            model: body["model"],
        } }));
}
async function _getCompletionsDeserialize(result) {
    if (isUnexpected(result)) {
        throw result.body.error;
    }
    return getCompletionsResult(result.body);
}
function getCompletionsResult(body) {
    const { created, choices, prompt_filter_results, prompt_annotations } = body, rest = tslib.__rest(body, ["created", "choices", "prompt_filter_results", "prompt_annotations"]);
    return Object.assign(Object.assign(Object.assign(Object.assign({}, camelCaseKeys(rest)), { created: new Date(created) }), {
        promptFilterResults: getContentFilterResultsForPrompt({
            prompt_filter_results,
            prompt_annotations,
        }),
    }), { choices: choices.map((_a) => {
            var { content_filter_results } = _a, choice = tslib.__rest(_a, ["content_filter_results"]);
            return (Object.assign(Object.assign({}, camelCaseKeys(choice)), (!content_filter_results
                ? {}
                : {
                    contentFilterResults: parseContentFilterResultsForChoiceOutput(content_filter_results),
                })));
        }) });
}
/**
 * Gets completions for the provided input prompts.
 * Completions support a wide variety of tasks and generate text that continues from or "completes"
 * provided prompt data.
 */
async function getCompletions(context, deploymentId, body, options = { requestOptions: {} }) {
    const result = await _getCompletionsSend(context, deploymentId, body, options);
    return _getCompletionsDeserialize(result);
}
function streamCompletions(context, deploymentName, prompt, options = { requestOptions: {} }) {
    const { abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = tslib.__rest(options, ["abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
    const response = _getCompletionsSend(context, deploymentName, Object.assign(Object.assign({ prompt }, rest), { stream: true }), { abortSignal, onResponse, requestOptions, tracingOptions });
    return getOaiSSEs(response, getCompletionsResult);
}
function _getChatCompletionsSend(context, deploymentId, body, options = { requestOptions: {} }) {
    var _a, _b, _c, _d, _e, _f, _g;
    return context.path("/deployments/{deploymentId}/chat/completions", deploymentId).post(Object.assign(Object.assign({}, coreClient.operationOptionsToRequestParameters(options)), { body: {
            model: body["model"],
            stream: body["stream"],
            max_tokens: body["maxTokens"],
            temperature: body["temperature"],
            top_p: body["topP"],
            logit_bias: body["logitBias"],
            user: body["user"],
            n: body["n"],
            stop: body["stop"],
            presence_penalty: body["presencePenalty"],
            frequency_penalty: body["frequencyPenalty"],
            data_sources: body["dataSources"] === undefined
                ? body["dataSources"]
                : body["dataSources"].map((p) => serializeAzureChatExtensionConfigurationUnion(p)),
            enhancements: !body.enhancements
                ? undefined
                : {
                    grounding: !((_a = body.enhancements) === null || _a === void 0 ? void 0 : _a.grounding)
                        ? undefined
                        : { enabled: (_c = (_b = body.enhancements) === null || _b === void 0 ? void 0 : _b.grounding) === null || _c === void 0 ? void 0 : _c["enabled"] },
                    ocr: !((_d = body.enhancements) === null || _d === void 0 ? void 0 : _d.ocr)
                        ? undefined
                        : { enabled: (_f = (_e = body.enhancements) === null || _e === void 0 ? void 0 : _e.ocr) === null || _f === void 0 ? void 0 : _f["enabled"] },
                },
            seed: body["seed"],
            logprobs: body["logprobs"],
            top_logprobs: body["topLogprobs"],
            response_format: !body.responseFormat ? undefined : { type: (_g = body.responseFormat) === null || _g === void 0 ? void 0 : _g["type"] },
            tool_choice: body["toolChoice"],
            tools: body["tools"],
            functions: body["functions"] === undefined
                ? body["functions"]
                : body["functions"].map((p) => ({
                    name: p["name"],
                    description: p["description"],
                    parameters: p["parameters"],
                })),
            function_call: body["functionCall"],
            messages: body["messages"].map((p) => serializeChatRequestMessageUnion(p)),
        } }));
}
async function _getChatCompletionsDeserialize(result) {
    if (isUnexpected(result)) {
        throw result.body.error;
    }
    return getChatCompletionsResult(result.body);
}
function getChatCompletionsResult(body) {
    const { created, choices, prompt_filter_results, prompt_annotations, usage } = body, rest = tslib.__rest(body, ["created", "choices", "prompt_filter_results", "prompt_annotations", "usage"]);
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, camelCaseKeys(rest)), { created: new Date(created) }), {
        promptFilterResults: getContentFilterResultsForPrompt({
            prompt_filter_results,
            prompt_annotations,
        }),
    }), (!usage
        ? {}
        : {
            usage: {
                completionTokens: usage["completion_tokens"],
                promptTokens: usage["prompt_tokens"],
                totalTokens: usage["total_tokens"],
            },
        })), { choices: !choices
            ? []
            : choices.map((_a) => {
                var { content_filter_results } = _a, choice = tslib.__rest(_a, ["content_filter_results"]);
                return (Object.assign(Object.assign({}, camelCaseKeys(choice)), (!content_filter_results
                    ? {}
                    : {
                        contentFilterResults: parseContentFilterResultsForChoiceOutput(content_filter_results),
                    })));
            }) });
}
/**
 * Gets chat completions for the provided chat messages.
 * Completions support a wide variety of tasks and generate text that continues from or "completes"
 * provided prompt data.
 */
async function getChatCompletions(context, deploymentName, messages, options = { requestOptions: {} }) {
    const result = await _getChatCompletionsSendX(context, deploymentName, messages, options);
    return _getChatCompletionsDeserialize(result);
}
function _getChatCompletionsSendX(context, deploymentName, messages, options = { requestOptions: {} }) {
    const { azureExtensionOptions, abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = tslib.__rest(options, ["azureExtensionOptions", "abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
    const coreOptions = {
        abortSignal,
        onResponse,
        requestOptions,
        tracingOptions,
    };
    const azure = Object.assign(Object.assign({}, (!(azureExtensionOptions === null || azureExtensionOptions === void 0 ? void 0 : azureExtensionOptions.extensions)
        ? {}
        : { dataSources: azureExtensionOptions.extensions })), (!(azureExtensionOptions === null || azureExtensionOptions === void 0 ? void 0 : azureExtensionOptions.enhancements)
        ? {}
        : { enhancements: azureExtensionOptions.enhancements }));
    return _getChatCompletionsSend(context, deploymentName, Object.assign(Object.assign({ messages }, rest), azure), coreOptions);
}
function streamChatCompletions(context, deploymentName, messages, options = { requestOptions: {} }) {
    const response = _getChatCompletionsSendX(context, deploymentName, messages, Object.assign(Object.assign({}, options), { stream: true }));
    return getOaiSSEs(response, getChatCompletionsResult);
}
function _getImageGenerationsSend(context, deploymentId, body, options = { requestOptions: {} }) {
    return context.path("/deployments/{deploymentId}/images/generations", deploymentId).post(Object.assign(Object.assign({}, coreClient.operationOptionsToRequestParameters(options)), { body: {
            model: body["model"],
            prompt: body["prompt"],
            n: body["n"],
            size: body["size"],
            response_format: body["responseFormat"],
            quality: body["quality"],
            style: body["style"],
            user: body["user"],
        } }));
}
async function _getImageGenerationsDeserialize(result) {
    if (isUnexpected(result)) {
        throw result.body.error;
    }
    return {
        created: new Date(result.body["created"]),
        data: result.body["data"].map((p) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25;
            return ({
                url: p["url"],
                base64Data: p["b64_json"],
                contentFilterResults: !p.content_filter_results
                    ? undefined
                    : {
                        sexual: !((_a = p.content_filter_results) === null || _a === void 0 ? void 0 : _a.sexual)
                            ? undefined
                            : {
                                severity: (_c = (_b = p.content_filter_results) === null || _b === void 0 ? void 0 : _b.sexual) === null || _c === void 0 ? void 0 : _c["severity"],
                                filtered: (_e = (_d = p.content_filter_results) === null || _d === void 0 ? void 0 : _d.sexual) === null || _e === void 0 ? void 0 : _e["filtered"],
                            },
                        violence: !((_f = p.content_filter_results) === null || _f === void 0 ? void 0 : _f.violence)
                            ? undefined
                            : {
                                severity: (_h = (_g = p.content_filter_results) === null || _g === void 0 ? void 0 : _g.violence) === null || _h === void 0 ? void 0 : _h["severity"],
                                filtered: (_k = (_j = p.content_filter_results) === null || _j === void 0 ? void 0 : _j.violence) === null || _k === void 0 ? void 0 : _k["filtered"],
                            },
                        hate: !((_l = p.content_filter_results) === null || _l === void 0 ? void 0 : _l.hate)
                            ? undefined
                            : {
                                severity: (_o = (_m = p.content_filter_results) === null || _m === void 0 ? void 0 : _m.hate) === null || _o === void 0 ? void 0 : _o["severity"],
                                filtered: (_q = (_p = p.content_filter_results) === null || _p === void 0 ? void 0 : _p.hate) === null || _q === void 0 ? void 0 : _q["filtered"],
                            },
                        selfHarm: !((_r = p.content_filter_results) === null || _r === void 0 ? void 0 : _r.self_harm)
                            ? undefined
                            : {
                                severity: (_t = (_s = p.content_filter_results) === null || _s === void 0 ? void 0 : _s.self_harm) === null || _t === void 0 ? void 0 : _t["severity"],
                                filtered: (_v = (_u = p.content_filter_results) === null || _u === void 0 ? void 0 : _u.self_harm) === null || _v === void 0 ? void 0 : _v["filtered"],
                            },
                    },
                revisedPrompt: p["revised_prompt"],
                promptFilterResults: !p.prompt_filter_results
                    ? undefined
                    : {
                        sexual: !((_w = p.prompt_filter_results) === null || _w === void 0 ? void 0 : _w.sexual)
                            ? undefined
                            : {
                                severity: (_y = (_x = p.prompt_filter_results) === null || _x === void 0 ? void 0 : _x.sexual) === null || _y === void 0 ? void 0 : _y["severity"],
                                filtered: (_0 = (_z = p.prompt_filter_results) === null || _z === void 0 ? void 0 : _z.sexual) === null || _0 === void 0 ? void 0 : _0["filtered"],
                            },
                        violence: !((_1 = p.prompt_filter_results) === null || _1 === void 0 ? void 0 : _1.violence)
                            ? undefined
                            : {
                                severity: (_3 = (_2 = p.prompt_filter_results) === null || _2 === void 0 ? void 0 : _2.violence) === null || _3 === void 0 ? void 0 : _3["severity"],
                                filtered: (_5 = (_4 = p.prompt_filter_results) === null || _4 === void 0 ? void 0 : _4.violence) === null || _5 === void 0 ? void 0 : _5["filtered"],
                            },
                        hate: !((_6 = p.prompt_filter_results) === null || _6 === void 0 ? void 0 : _6.hate)
                            ? undefined
                            : {
                                severity: (_8 = (_7 = p.prompt_filter_results) === null || _7 === void 0 ? void 0 : _7.hate) === null || _8 === void 0 ? void 0 : _8["severity"],
                                filtered: (_10 = (_9 = p.prompt_filter_results) === null || _9 === void 0 ? void 0 : _9.hate) === null || _10 === void 0 ? void 0 : _10["filtered"],
                            },
                        selfHarm: !((_11 = p.prompt_filter_results) === null || _11 === void 0 ? void 0 : _11.self_harm)
                            ? undefined
                            : {
                                severity: (_13 = (_12 = p.prompt_filter_results) === null || _12 === void 0 ? void 0 : _12.self_harm) === null || _13 === void 0 ? void 0 : _13["severity"],
                                filtered: (_15 = (_14 = p.prompt_filter_results) === null || _14 === void 0 ? void 0 : _14.self_harm) === null || _15 === void 0 ? void 0 : _15["filtered"],
                            },
                        profanity: !((_16 = p.prompt_filter_results) === null || _16 === void 0 ? void 0 : _16.profanity)
                            ? undefined
                            : {
                                filtered: (_18 = (_17 = p.prompt_filter_results) === null || _17 === void 0 ? void 0 : _17.profanity) === null || _18 === void 0 ? void 0 : _18["filtered"],
                                detected: (_20 = (_19 = p.prompt_filter_results) === null || _19 === void 0 ? void 0 : _19.profanity) === null || _20 === void 0 ? void 0 : _20["detected"],
                            },
                        jailbreak: !((_21 = p.prompt_filter_results) === null || _21 === void 0 ? void 0 : _21.jailbreak)
                            ? undefined
                            : {
                                filtered: (_23 = (_22 = p.prompt_filter_results) === null || _22 === void 0 ? void 0 : _22.jailbreak) === null || _23 === void 0 ? void 0 : _23["filtered"],
                                detected: (_25 = (_24 = p.prompt_filter_results) === null || _24 === void 0 ? void 0 : _24.jailbreak) === null || _25 === void 0 ? void 0 : _25["detected"],
                            },
                    },
            });
        }),
    };
}
/** Creates an image given a prompt. */
async function getImageGenerations(context, deploymentId, body, options = { requestOptions: {} }) {
    const result = await _getImageGenerationsSend(context, deploymentId, body, options);
    return _getImageGenerationsDeserialize(result);
}
function _getEmbeddingsSend(context, deploymentId, body, options = { requestOptions: {} }) {
    return context.path("/deployments/{deploymentId}/embeddings", deploymentId).post(Object.assign(Object.assign({}, coreClient.operationOptionsToRequestParameters(options)), { body: {
            user: body["user"],
            model: body["model"],
            input: body["input"],
            dimensions: body["dimensions"],
        } }));
}
async function _getEmbeddingsDeserialize(result) {
    if (isUnexpected(result)) {
        throw result.body.error;
    }
    return {
        data: result.body["data"].map((p) => ({
            embedding: p["embedding"],
            index: p["index"],
        })),
        usage: {
            promptTokens: result.body.usage["prompt_tokens"],
            totalTokens: result.body.usage["total_tokens"],
        },
    };
}
/** Return the embeddings for a given prompt. */
async function getEmbeddings(context, deploymentId, body, options = { requestOptions: {} }) {
    const result = await _getEmbeddingsSend(context, deploymentId, body, options);
    return _getEmbeddingsDeserialize(result);
}
function getContentFilterResultsForPrompt({ prompt_annotations, prompt_filter_results, }) {
    const res = prompt_filter_results !== null && prompt_filter_results !== void 0 ? prompt_filter_results : prompt_annotations;
    return res === null || res === void 0 ? void 0 : res.map((_a) => {
        var { content_filter_results } = _a, rest = tslib.__rest(_a, ["content_filter_results"]);
        return (Object.assign(Object.assign({}, camelCaseKeys(rest)), { contentFilterResults: parseContentFilterResultDetailsForPromptOutput(content_filter_results) }));
    });
}
function parseContentFilterResultDetailsForPromptOutput(_a = {}) {
    var { error } = _a, rest = tslib.__rest(_a, ["error"]);
    return error ? parseError(error) : camelCaseKeys(rest);
}
function parseError(error) {
    var _a;
    return {
        error: Object.assign(Object.assign({}, error), { details: (_a = error["details"]) !== null && _a !== void 0 ? _a : [] }),
    };
}
function parseContentFilterResultsForChoiceOutput(_a = {}) {
    var _b;
    var { error } = _a, successResult = tslib.__rest(_a, ["error"]);
    return error
        ? {
            error: Object.assign(Object.assign({}, error), { details: (_b = error["details"]) !== null && _b !== void 0 ? _b : [] }),
        }
        : camelCaseKeys(successResult);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function nonAzurePolicy() {
    const policy = {
        name: "openAiEndpoint",
        sendRequest: (request, next) => {
            const obj = new URL(request.url);
            const parts = obj.pathname.split("/");
            switch (parts[parts.length - 1]) {
                case "completions":
                    if (parts[parts.length - 2] === "chat") {
                        obj.pathname = `${parts[1]}/chat/completions`;
                    }
                    else {
                        obj.pathname = `${parts[1]}/completions`;
                    }
                    break;
                case "embeddings":
                    obj.pathname = `${parts[1]}/embeddings`;
                    break;
                case "generations":
                    if (parts[parts.length - 2] === "images") {
                        obj.pathname = `${parts[1]}/images/generations`;
                    }
                    else {
                        throw new Error("Unexpected path");
                    }
                    break;
                case "transcriptions":
                    obj.pathname = `${parts[1]}/audio/transcriptions`;
                    break;
                case "translations":
                    obj.pathname = `${parts[1]}/audio/translations`;
                    break;
            }
            obj.searchParams.delete("api-version");
            request.url = obj.toString();
            return next(request);
        },
    };
    return policy;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function createOpenAIEndpoint(version) {
    return `https://api.openai.com/v${version}`;
}
function isCred(cred) {
    return coreAuth.isTokenCredential(cred) || cred.key !== undefined;
}
/**
 * A client for interacting with Azure OpenAI.
 *
 * The client needs the endpoint of an OpenAI resource and an authentication
 * method such as an API key or token. The API key and endpoint can be found in
 * the OpenAI resource page. They will be located in the resource's Keys and Endpoint page.
 *
 * ### Examples for authentication:
 *
 * #### API Key
 *
 * ```js
 * import { OpenAIClient } from "@azure/openai";
 * import { AzureKeyCredential } from "@azure/core-auth";
 *
 * const endpoint = "<azure endpoint>";
 * const credential = new AzureKeyCredential("<api key>");
 *
 * const client = new OpenAIClient(endpoint, credential);
 * ```
 *
 * #### Azure Active Directory
 *
 * ```js
 * import { OpenAIClient } from "@azure/openai";
 * import { DefaultAzureCredential } from "@azure/identity";
 *
 * const endpoint = "<azure endpoint>";
 * const credential = new DefaultAzureCredential();
 *
 * const client = new OpenAIClient(endpoint, credential);
 * ```
 */
class OpenAIClient {
    constructor(endpointOrOpenAiKey, credOrOptions = {}, options = {}) {
        var _a, _b;
        this._isAzure = false;
        let opts;
        let endpoint;
        let cred;
        if (isCred(credOrOptions)) {
            endpoint = endpointOrOpenAiKey;
            cred = credOrOptions;
            opts = options;
            this._isAzure = true;
        }
        else {
            endpoint = createOpenAIEndpoint(1);
            cred = endpointOrOpenAiKey;
            const { credentials } = credOrOptions, restOpts = tslib.__rest(credOrOptions, ["credentials"]);
            opts = Object.assign({ credentials: {
                    apiKeyHeaderName: (_a = credentials === null || credentials === void 0 ? void 0 : credentials.apiKeyHeaderName) !== null && _a !== void 0 ? _a : "Authorization",
                    scopes: credentials === null || credentials === void 0 ? void 0 : credentials.scopes,
                } }, restOpts);
        }
        this._client = createOpenAI(endpoint, cred, Object.assign(Object.assign({}, opts), (this._isAzure
            ? {}
            : {
                additionalPolicies: [
                    ...((_b = opts.additionalPolicies) !== null && _b !== void 0 ? _b : []),
                    {
                        position: "perCall",
                        policy: nonAzurePolicy(),
                    },
                ],
            })));
    }
    setModel(model, options) {
        if (!this._isAzure) {
            options.model = model;
        }
    }
    // implementation
    async getAudioTranslation(deploymentName, fileContent, formatOrOptions, inputOptions) {
        const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : (typeof formatOrOptions === "string" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {});
        const response_format = typeof formatOrOptions === "string" ? formatOrOptions : undefined;
        this.setModel(deploymentName, options);
        if (response_format === undefined) {
            return getAudioTranslation(this._client, deploymentName, fileContent, options);
        }
        return getAudioTranslation(this._client, deploymentName, fileContent, response_format, options);
    }
    // implementation
    async getAudioTranscription(deploymentName, fileContent, formatOrOptions, inputOptions) {
        const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : (typeof formatOrOptions === "string" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {});
        const response_format = typeof formatOrOptions === "string" ? formatOrOptions : undefined;
        this.setModel(deploymentName, options);
        if (response_format === undefined) {
            return getAudioTranscription(this._client, deploymentName, fileContent, options);
        }
        return getAudioTranscription(this._client, deploymentName, fileContent, response_format, options);
    }
    /**
     * Gets completions for the provided input prompts.
     * Completions support a wide variety of tasks and generate text that continues from or "completes"
     * provided prompt data.
     */
    getCompletions(deploymentName, prompt, options = { requestOptions: {} }) {
        this.setModel(deploymentName, options);
        const { abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = tslib.__rest(options, ["abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
        return getCompletions(this._client, deploymentName, Object.assign({ prompt }, rest), { abortSignal, onResponse, requestOptions, tracingOptions });
    }
    /**
     * Lists the completions tokens as they become available for a given prompt.
     * @param deploymentName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
     * @param prompt - The prompt to use for this request.
     * @param options - The completions options for this completions request.
     * @returns An asynchronous iterable of completions tokens.
     */
    streamCompletions(deploymentName, prompt, options = {}) {
        this.setModel(deploymentName, options);
        return streamCompletions(this._client, deploymentName, prompt, options);
    }
    /**
     * Gets chat completions for the provided chat messages.
     * Completions support a wide variety of tasks and generate text that continues from or "completes"
     * provided prompt data.
     */
    getChatCompletions(deploymentName, messages, options = { requestOptions: {} }) {
        this.setModel(deploymentName, options);
        return getChatCompletions(this._client, deploymentName, messages, options);
    }
    /**
     * Lists the chat completions tokens as they become available for a chat context.
     * @param deploymentName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
     * @param messages - The chat context messages to use for this request.
     * @param options - The chat completions options for this chat completions request.
     * @returns An asynchronous iterable of chat completions tokens.
     */
    streamChatCompletions(deploymentName, messages, options = { requestOptions: {} }) {
        this.setModel(deploymentName, options);
        return streamChatCompletions(this._client, deploymentName, messages, options);
    }
    /** Creates an image given a prompt. */
    getImages(deploymentName, prompt, options = { requestOptions: {} }) {
        this.setModel(deploymentName, options);
        const { abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = tslib.__rest(options, ["abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
        return getImageGenerations(this._client, deploymentName, Object.assign({ prompt }, rest), { abortSignal, onResponse, requestOptions, tracingOptions });
    }
    /** Return the embeddings for a given prompt. */
    getEmbeddings(deploymentName, input, options = { requestOptions: {} }) {
        this.setModel(deploymentName, options);
        const { abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = tslib.__rest(options, ["abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
        return getEmbeddings(this._client, deploymentName, Object.assign({ input }, rest), { abortSignal, onResponse, requestOptions, tracingOptions });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The OpenAIKeyCredential class represents an OpenAI API key
 * and is used to authenticate into an OpenAI client for
 * an OpenAI endpoint.
 */
class OpenAIKeyCredential {
    /**
     * Create an instance of an AzureKeyCredential for use
     * with a service client.
     *
     * @param key - The initial value of the key to use in authentication
     */
    constructor(key) {
        if (!key) {
            throw new Error("key must be a non-empty string");
        }
        this._key = createKey(key);
    }
    /**
     * The value of the key to be used in authentication
     */
    get key() {
        return this._key;
    }
    /**
     * Change the value of the key.
     *
     * Updates will take effect upon the next request after
     * updating the key value.
     *
     * @param newKey - The new key value to be used
     */
    update(newKey) {
        this._key = createKey(newKey);
    }
}
function createKey(key) {
    return key.startsWith("Bearer ") ? key : `Bearer ${key}`;
}

Object.defineProperty(exports, "AzureKeyCredential", {
    enumerable: true,
    get: function () { return coreAuth.AzureKeyCredential; }
});
exports.OpenAIClient = OpenAIClient;
exports.OpenAIKeyCredential = OpenAIKeyCredential;
//# sourceMappingURL=index.cjs.map
